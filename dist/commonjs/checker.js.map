{"version":3,"sources":["../src/checker.ts"],"names":[],"mappings":"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","file":"checker.js","sourcesContent":["import * as ts from 'typescript';\nimport * as chalk from 'chalk';\nimport * as tslint from 'tslint';\nimport * as path from 'path';\nimport { IInternalTypeCheckerOptions, END_LINE } from './interfaces';\n\n\nexport class Checker {\n\n    // options that will be used when checking and printing results\n    private options: IInternalTypeCheckerOptions;\n\n    // typescript program\n    private program: ts.Program;\n\n    // time used to do typecheck/linting\n    private elapsedInspectionTime: number;\n\n    // type diagonstic returned by typescript\n    private tsDiagnostics: ts.Diagnostic[];\n\n    // lint result returned by tsLint\n    private lintFileResult: tslint.LintResult[];\n\n\n    constructor() {\n        // nothing atm\n    }\n\n\n    public inspectCode(options: IInternalTypeCheckerOptions) {\n        this.options = options;\n\n\n        // parse it right away, no need to wait...\n        const parseConfigHost: any = {\n            fileExists: ts.sys.fileExists,\n            readDirectory: ts.sys.readDirectory,\n            readFile: ts.sys.readFile,\n            useCaseSensitiveFileNames: true\n        };\n\n        // take the time\n        let inspectionTimeStart = new Date().getTime();\n\n        // get program and get diagnostics and store them diagnostics\n        const parsed = ts.parseJsonConfigFileContent(this.options.tsConfigJsonContent, parseConfigHost, options.basePath || '.', undefined);\n        this.program = ts.createProgram(parsed.fileNames, parsed.options, undefined, this.program);\n\n\n        // get errors and tag them;\n        this.tsDiagnostics = [];\n        let optionsErrors = this.program.getOptionsDiagnostics().map((obj) => {\n            // tag em so we know for later\n            (<any>obj)._type = 'options';\n            return obj;\n        });\n        this.tsDiagnostics = this.tsDiagnostics.concat(optionsErrors);\n\n\n\n        let globalErrors = this.program.getGlobalDiagnostics().map((obj) => {\n            (<any>obj)._type = 'global';\n            return obj;\n        });\n        this.tsDiagnostics = this.tsDiagnostics.concat(globalErrors);\n\n\n\n        let syntacticErrors = this.program.getSyntacticDiagnostics().map((obj) => {\n            (<any>obj)._type = 'syntactic';\n            return obj;\n        });\n        this.tsDiagnostics = this.tsDiagnostics.concat(syntacticErrors);\n\n\n\n        let semanticErrors = this.program.getSemanticDiagnostics().map((obj) => {\n            (<any>obj)._type = 'semantic';\n            return obj;\n        });\n        this.tsDiagnostics = this.tsDiagnostics.concat(semanticErrors);\n\n\n        // get tslint if json file is supplied\n        this.lintFileResult = [];\n        if (options.tsLint) {\n\n            // get full path\n            let fullPath = path.resolve(this.options.basePath, options.tsLint);\n\n            // gets the files, lint every file and store errors in lintResults\n            let files = tslint.Linter.getFileNames(this.program);\n\n            // get tslint configuration\n            const tsLintConfiguration = tslint.Configuration.findConfiguration(fullPath, this.options.basePath).results;\n\n            // lint the files\n            this.lintFileResult =\n                files.map(file => {\n                    // get content of file\n                    const fileContents = this.program.getSourceFile(file).getFullText();\n\n                    // create new linter using lint options and tsprogram\n                    const linter = new tslint.Linter((<tslint.ILinterOptions>options.lintoptions), this.program);\n\n                    // lint file using filename, filecontent, and tslint configuration\n                    linter.lint(file, fileContents, tsLintConfiguration);\n\n                    // return result\n                    return linter.getResult();\n                }).filter((result) => {\n                    // only return the one with erros\n                    return result.errorCount ? true : false;\n                });\n        }\n\n        // save elapsed check time\n        this.elapsedInspectionTime = new Date().getTime() - inspectionTimeStart;\n    }\n\n\n\n    /**\n     * print result\n     *\n     */\n    public printResult(isWorker?: boolean) {\n\n        // consts\n        const print = this.writeText;\n        const program = this.program;\n        const options = this.options;\n\n        // print header\n        print(\n            chalk.bgWhite(\n                chalk.black(`${END_LINE}Typechecker plugin(${options.type}) ${options.name}`)\n            ) +\n            chalk.white(`.${END_LINE}`)\n        );\n\n        // print time\n        print(\n            chalk.grey(`Time:${new Date().toString()} ${END_LINE}`)\n        );\n\n        // get the lint errors messages\n        let lintErrorMessages = this.processLintFiles();\n\n        // loop diagnostics and get the errors messages\n        let tsErrorMessages = this.processTsDiagnostics();\n\n        // combine errors and print if any\n        let allErrors = tsErrorMessages.concat(lintErrorMessages);\n\n        // print if any\n        if (allErrors.length > 0) {\n\n            // insert header\n            allErrors.unshift(\n                chalk.underline(`${END_LINE}File errors`) + chalk.white(':') // fix windows\n            );\n\n            print(allErrors.join(END_LINE));\n        }\n\n        // time for summary >>>>>\n\n        // get errors totals\n        let optionsErrors = program.getOptionsDiagnostics().length;\n        let globalErrors = program.getGlobalDiagnostics().length;\n        let syntacticErrors = program.getSyntacticDiagnostics().length;\n        let semanticErrors = program.getSemanticDiagnostics().length;\n        let tsLintErrors = lintErrorMessages.length;\n        let totalsErrors = optionsErrors + globalErrors + syntacticErrors + semanticErrors + tsLintErrors;\n\n\n\n        // if errors, show user\n        if (totalsErrors) {\n\n            // write header\n            print(\n                chalk.underline(`${END_LINE}${END_LINE}Errors`) +\n                chalk.white(`:${totalsErrors}${END_LINE}`)\n            );\n\n            print(\n                chalk[optionsErrors ? options.yellowOnOptions ? 'yellow' : 'red' : 'white']\n                    (`└── Options: ${optionsErrors}${END_LINE}`)\n            );\n\n            print(\n                chalk[globalErrors ? options.yellowOnGlobal ? 'yellow' : 'red' : 'white']\n                    (`└── Global: ${globalErrors}${END_LINE}`)\n            );\n\n            print(\n                chalk[syntacticErrors ? options.yellowOnSyntactic ? 'yellow' : 'red' : 'white']\n                    (`└── Syntactic: ${syntacticErrors}${END_LINE}`)\n            );\n\n            print(\n                chalk[semanticErrors ? options.yellowOnSemantic ? 'yellow' : 'red' : 'white']\n                    (`└── Semantic: ${semanticErrors}${END_LINE}`)\n            );\n\n            print(\n                chalk[tsLintErrors ? options.yellowOnLint ? 'yellow' : 'red' : 'white']\n                    (`└── TsLint: ${tsLintErrors}${END_LINE}${END_LINE}`)\n            );\n\n        } else {\n            // if there no errors, then also give some feedback about this, so they know its working\n            print(\n                chalk.grey(`All good, no errors :-)${END_LINE}`)\n            );\n        }\n\n        print(\n            chalk.grey(`Typechecking time: ${this.elapsedInspectionTime}ms${END_LINE}`)\n        );\n\n\n        // final check how to end the checker, throw, exit or keep alive\n\n        switch (true) {\n\n            // if throwError is set then callback and quit\n            case options.throwOnGlobal && globalErrors > 0:\n            case options.throwOnOptions && optionsErrors > 0:\n            case options.throwOnSemantic && semanticErrors > 0:\n            case options.throwOnTsLint && tsLintErrors > 0:\n            case options.throwOnSyntactic && syntacticErrors > 0:\n                if (process.send) {\n                    process.send('error');\n                } else {\n                    throw new Error('Typechecker throwing error due to throw options set');\n                }\n                // exit with error\n                process.exit(1);\n                break;\n\n            // if quit is set and its a worker, then post message and callback to main tread and tell its done\n            case options.quit && isWorker:\n                print(chalk.grey(`Quiting typechecker${END_LINE}${END_LINE}`));\n\n                // since Im a worker I need to send back a message;\n                (<any>process).send('done');\n                break;\n\n            // if quit is set and not worker, then just post messeage\n            case options.quit && !isWorker:\n                print(chalk.grey(`Quiting typechecker${END_LINE}${END_LINE}`));\n                break;\n\n            // default action\n            default:\n                print(chalk.grey(`Keeping typechecker alive${END_LINE}${END_LINE}`));\n        }\n\n        return totalsErrors;\n\n    }\n\n\n\n    /**\n     * write to screen helper\n     *\n     */\n    private writeText(text: string) {\n        ts.sys.write(text);\n    }\n\n\n\n    /**\n     * loops lint failures and return pretty failure string ready to be printed\n     *\n     */\n    private processLintFiles(): string[] {\n\n        const options = this.options;\n\n        // loop lint results\n        let lintResultsFilesMessages =\n            this.lintFileResult.map((fileResult: tslint.LintResult) => {\n                let messages: string[] = [];\n                if (fileResult.failures) {\n                    // we have a failure, lets check its failures\n                    messages = fileResult.failures.map((failure: any) => {\n\n                        // simplify it so its more readable later\n                        let r = {\n                            fileName: failure.fileName,\n                            line: failure.startPosition.lineAndCharacter.line,\n                            char: failure.startPosition.lineAndCharacter.character,\n                            ruleSeverity: failure.ruleSeverity.charAt(0).toUpperCase() + failure.ruleSeverity.slice(1),\n                            ruleName: failure.ruleName,\n                            failure: failure.failure\n                        };\n\n                        // make error pretty and return it\n                        let message = chalk.red('└── ');\n                        message += chalk[options.yellowOnLint ? 'yellow' : 'red'](`${r.fileName} (${r.line + 1},${r.char + 1}) `);\n                        message += chalk.white(`(${r.ruleSeverity}:`);\n                        message += chalk.white(`${r.ruleName})`);\n                        message += ' ' + r.failure;\n                        return message;\n                    });\n                }\n                // return messages\n                return messages;\n\n            }).filter((res: string[]) => {\n                // filter our only messages with content\n                return res.length === 0 ? false : true;\n            });\n\n        // flatten/concatenate lint files - > failures\n        let lintErrorMessages: string[] = [];\n        try {\n            if (lintResultsFilesMessages.length) {\n                lintErrorMessages = lintResultsFilesMessages.reduce((a: string[], b: string[]) => {\n                    return a.concat(b);\n                });\n            }\n        } catch (err) {\n            console.log(err);\n        }\n\n        return lintErrorMessages;\n    }\n\n\n\n    /**\n     * loops ts failures and return pretty failure string ready to be printed\n     *\n     */\n    private processTsDiagnostics(): string[] {\n\n        const options = this.options;\n        let tsErrorMessages: string[] = [];\n\n        if (this.tsDiagnostics.length > 0) {\n            tsErrorMessages = this.tsDiagnostics.map((diag: any) => {\n\n                // get message type error, warn, info\n                let message = chalk.red('└── ');\n\n                // set color from options\n                let color: string;\n                switch (diag._type) {\n                    case 'options':\n                        color = options.yellowOnOptions ? 'yellow' : 'red';\n                        break;\n                    case 'global':\n                        color = options.yellowOnGlobal ? 'yellow' : 'red';\n                        break;\n                    case 'syntactic':\n                        color = options.yellowOnSyntactic ? 'yellow' : 'red';\n                        break;\n                    case 'semantic':\n                        color = options.yellowOnSemantic ? 'yellow' : 'red';\n                        break;\n                    default:\n                        color = 'red';\n                }\n\n                // if file\n                if (diag.file) {\n                    const {\n                        line,\n                        character\n                    } = diag.file.getLineAndCharacterOfPosition(diag.start);\n\n                    message += chalk[color](`${diag.file.fileName} (${line + 1},${character + 1}) `);\n                    message += chalk.white(`(${ts.DiagnosticCategory[diag.category]}:`);\n                    message += chalk.white(`TS${diag.code})`);\n                }\n\n                // flatten error message\n                message += ' ' + ts.flattenDiagnosticMessageText(diag.messageText, END_LINE);\n\n                // return message\n                return message;\n            });\n        }\n\n        return tsErrorMessages;\n    }\n\n\n}\n"],"sourceRoot":"src/"}